import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class DltMessage {

    //! The header parameter ECU Id.
    public String ecuid;

    //! The header parameter application Id.
    public String apid;

    //! The header parameter context Id.
    public String ctid;

    //! The header parameter type of the message.
    public DltTypeDef type;

    /**
     * Message Type Info field (MTIN)
     */
    public int mtin;

    /**
     * subtype of control message
     */
    public DltControlMessageType controlSubtype;

    /**
     * level of log messages
     */
    DltLogMessageLevel logLevel;

    /**
     * Type of trace messages
     */
    DltTraceMessageType traceSubtype;

    /**
     * Type of network trace messages
     */
    DltNwTraceMessageType nwTraceSubtype;

    //! The verbose or non-verbose mode of the message.
    public DltModeDef mode;

    //! The endianness of the payload of the message.
    public DltEndianness endianness;

    //! The time, seconds part, of the message generated by the logger.
    public long time;

    //! The time, microseconds part, of the message generated by the logger.
    public long microseconds;

    //! The timestamp generated by the ECU.
    public long timestamp;

    //! The session id of the DLT message.
    public long sessionid;

    //! The session name of the DLT message.
    public String sessionName;

    //! The message counter of a context.
    public int messageCounter;

    //! The number of arguments of the DLT message.
    public int numberOfArguments;

    //! The complete header of the DLT message.
    public byte[] header;
    public int headerSize;

    //! The complete payload of the DLT message.
    public byte[] payload;
    public int payloadSize;

    //! The message id if this is a non-verbose message and no control message.
    public long messageId;

    //! The service id if the message is a ctrl message.
    public long ctrlServiceId;

    //! The return type if the message is a ctrl response message.
    public int ctrlReturnType;

    //! List of arguments of the DLT message.
    public List<DltArgument> arguments = new ArrayList<>();

    public int getHeaderSize() {
        return headerSize;
    }

    public int getPayloadSize() {
        return payloadSize;
    }

    public boolean setMsg(byte[] buf, int pos, int len, boolean withStorageHeader) {

        if (DltUtil.debug)
            System.out.println("setMsg " + pos + " " + len + " " + withStorageHeader);

        int offset;
        DltStorageHeader storageheader = null;
        DltStandardHeader standardheader = null;
        DltExtendedHeader extendedheader = null;
        DltStandardHeaderExtra headerextra;
        int extra_size;
        int sizeStorageHeader;
        DltEndianness endianness;

        /* empty message */
        clear();

        /* set offset of storage header */
        if (withStorageHeader) {
            sizeStorageHeader = DltStorageHeader.sizeOf;
        } else {
            sizeStorageHeader = 0;
        }


        if (len < (int) (sizeStorageHeader + DltStandardHeader.sizeOf)) {
            return false;
        }

        // htyp of standard-header
        int htyp = ((int) buf[pos + sizeStorageHeader]) & 0x00FF;

        /* extract endianness by test htyp of standard-header */
        if (0 != (htyp & DltConstants.DLT_HTYP_MSBF)) {
            endianness = DltEndianness.BigEndian;
        } else {
            endianness = DltEndianness.LittleEndian;
        }

        final boolean useExtendedHeader = (0 != (DltConstants.DLT_HTYP_UEH & htyp));

        // Header and extra header are always in Big Endian
        DltStream s = new DltStream(buf, pos, len, DltEndianness.BigEndian);

        if (withStorageHeader) {
            storageheader = new DltStorageHeader(s);
        }
        standardheader = new DltStandardHeader(s);

        /* calculate complete size of headers */
        extra_size = (useExtendedHeader ? DltExtendedHeader.sizeOf : 0);
        if (0 != (DltConstants.DLT_HTYP_WEID & htyp)) extra_size += DltConstants.DLT_SIZE_WEID;
        if (0 != (DltConstants.DLT_HTYP_WSID & htyp)) extra_size += DltConstants.DLT_SIZE_WSID;
        if (0 != (DltConstants.DLT_HTYP_WTMS & htyp)) extra_size += DltConstants.DLT_SIZE_WTMS;

        /* payload size */
        payloadSize = standardheader.len - (DltStandardHeader.sizeOf + extra_size);
        if (payloadSize < 0) {
            // there is something wrong with the header, at least size of header
            // at the moment no error, distinguish different errors needed
            payloadSize = 0;
        }
        headerSize = sizeStorageHeader + DltStandardHeader.sizeOf + extra_size;

        /* check header length */
        if (len < headerSize) {
            return false;
        }

        /* copy header */
        header = Arrays.copyOfRange(buf, pos, pos + headerSize);

        headerextra = new DltStandardHeaderExtra(s, htyp);

        /* load standard header extra parameters and Extended header if used */
        if (extra_size > 0) {
            /* set extended header and get standard header extra parameters */
            if (useExtendedHeader) {
                extendedheader = new DltExtendedHeader(s);
            }
        }

        /* extract ecu id */
        if (0 != (DltConstants.DLT_HTYP_WEID & htyp)) {
            ecuid = headerextra.ecu;
        } else {
            if (storageheader != null)
                ecuid = storageheader.ecu;
        }


        if (extendedheader != null) {
            /* extract application id */
            apid = extendedheader.apid;
            /* extract context id */
            ctid = extendedheader.ctid;

            /* extract type */
            switch ((((extendedheader.msin) & DltConstants.DLT_MSIN_MSTP) >> DltConstants.DLT_MSIN_MSTP_SHIFT)) {
                case 0 -> type = DltTypeDef.Log;
                case 1 -> type = DltTypeDef.AppTrace;
                case 2 -> type = DltTypeDef.NwTrace;
                case 3 -> type = DltTypeDef.Control;
                default -> type = DltTypeDef.Unknown;
            }

            /* extract subtype */
            final int mtin = (((extendedheader.msin) & DltConstants.DLT_MSIN_MTIN) >> DltConstants.DLT_MSIN_MTIN_SHIFT);
            switch (type) {
                case Log -> {
                    switch (mtin) {
                        case 1 -> logLevel = DltLogMessageLevel.Fatal;
                        case 2 -> logLevel = DltLogMessageLevel.Error;
                        case 3 -> logLevel = DltLogMessageLevel.Warn;
                        case 4 -> logLevel = DltLogMessageLevel.Info;
                        case 5 -> logLevel = DltLogMessageLevel.Debug;
                        case 6 -> logLevel = DltLogMessageLevel.Verb;
                        default -> logLevel = DltLogMessageLevel.Unknown;
                    }
                }
                case AppTrace -> {
                    switch (mtin) {
                        case 1 -> traceSubtype = DltTraceMessageType.Variable;
                        case 2 -> traceSubtype = DltTraceMessageType.FunctionIn;
                        case 3 -> traceSubtype = DltTraceMessageType.FunctionOut;
                        case 4 -> traceSubtype = DltTraceMessageType.State;
                        case 5 -> traceSubtype = DltTraceMessageType.Vfb;
                        default -> traceSubtype = DltTraceMessageType.Unknown;
                    }
                }
                case NwTrace -> {
                    switch (mtin) {
                        case 1 -> nwTraceSubtype = DltNwTraceMessageType.Ipc;
                        case 2 -> nwTraceSubtype = DltNwTraceMessageType.Can;
                        case 3 -> nwTraceSubtype = DltNwTraceMessageType.Flexray;
                        case 4 -> nwTraceSubtype = DltNwTraceMessageType.Most;
                        case 5 -> nwTraceSubtype = DltNwTraceMessageType.Ethernet;
                        case 6 -> nwTraceSubtype = DltNwTraceMessageType.SomeIP;
                        default -> nwTraceSubtype = DltNwTraceMessageType.Unknown;
                    }
                }
                case Control -> {
                    switch (mtin) {
                        case 1 -> controlSubtype = DltControlMessageType.Request;
                        case 2 -> controlSubtype = DltControlMessageType.Response;
                        case 3 -> controlSubtype = DltControlMessageType.Time;
                        default -> controlSubtype = DltControlMessageType.Unknown;
                    }
                }
            }

            if (0 != (extendedheader.msin & DltConstants.DLT_MSIN_VERB)) {
                mode = DltModeDef.Verbose;
            } else {
                mode = DltModeDef.NonVerbose;
            }
        } else {
            mode = DltModeDef.NonVerbose;
        }

        /* extract time */
        if (storageheader != null) {
            time = storageheader.seconds;
            microseconds = storageheader.microseconds;
        }

        /* extract timestamp */
        if (0 != (htyp & DltConstants.DLT_HTYP_WTMS)) {
            timestamp = headerextra.tmsp; /* big endian to host little endian conversion already done */
        }

        /* extract session id */
        if (0 != (htyp & DltConstants.DLT_HTYP_WSID)) {
            sessionid = headerextra.seid;
        }

        /* extract message counter */
        messageCounter = standardheader.mcnt;

        /* extract number of arguments */
        if (useExtendedHeader && (mode == DltModeDef.Verbose)) {
            numberOfArguments = extendedheader.noar;
        }

        /* check complete length */
        if (len < (int) (headerSize + payloadSize)) {
            return false;
        }

        /* copy payload */
        if (payloadSize > 0)
            payload = Arrays.copyOfRange(buf, pos + headerSize, pos + headerSize + payloadSize);

        /* set messageid if non verbose */
        if ((mode == DltModeDef.NonVerbose) && payload.length >= 4) {
            DltStream ms = new DltStream(payload, 0, payload.length, endianness);
            messageId = ms.readInteger(4, false);
        }

        /* set service id if message of type control */
        if ((type == DltTypeDef.Control) && payload.length >= 4) {
            DltStream ms = new DltStream(payload, 0, payload.length, endianness);
            ctrlServiceId = ms.readInteger(4, false);
        }

        /* set return type if message of type control response */
        if ((type == DltTypeDef.Control) && (controlSubtype == DltControlMessageType.Response) && payload.length >= 5) {
            ctrlReturnType = ((int) payload[4]) & 0x00FF;
        }

        /* get the arguments of the payload */
        if (mode == DltModeDef.Verbose) {
            DltArgument argument;
            arguments.clear();
            DltStream argS = new DltStream(payload, 0, payloadSize, endianness);
            for (int num = 0; num < numberOfArguments; num++) {
                argument = new DltArgument();
                if (!argument.setArgument(argS)) {
                    // There was an error parsing the arguments
                    return false;
                }
                arguments.add(argument);
            }
        }
        return true;
    }

    void clear() {
        ecuid = "";
        apid = ecuid;
        ctid = ecuid;
        mtin = 0;
        type = DltTypeDef.Unknown;
        controlSubtype = DltControlMessageType.Unknown;
        logLevel = DltLogMessageLevel.Unknown;
        traceSubtype = DltTraceMessageType.Unknown;
        nwTraceSubtype = DltNwTraceMessageType.Unknown;
        mode = DltModeDef.Unknown;
        endianness = DltEndianness.Unknown;
        time = 0;
        microseconds = 0;
        timestamp = 0;
        sessionid = 0;
        sessionName = ecuid;
        numberOfArguments = 0;
        messageId = 0;
        ctrlServiceId = 0;
        ctrlReturnType = 0;
        arguments.clear();
        payload = new byte[0];
        payloadSize = 0;
        header = new byte[0];
        headerSize = 0;
    }

    public String toStringPayload() {
        StringBuilder text = new StringBuilder(1024);

        if ((mode == DltModeDef.NonVerbose) && (type != DltTypeDef.Control) &&
                (numberOfArguments == 0)) {
            text.append('[').append(messageId).append(']');

            if (payload.length > 4) {
                text.append(DltUtil.toAscii(Arrays.copyOfRange(payload, 4, payload.length), DltUtil.ToAsciiMode.HEX));
            }
            return text.toString();
        }

        if (type == DltTypeDef.Control && controlSubtype == DltControlMessageType.Response) {

            if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_MARKER) {
                return "MARKER";
            }

            text.append('[').append(getCtrlServiceIdString()).append(' ').append(getCtrlReturnTypeString()).
                    append("] ");

            // ServiceID of Get ECU Software Version
            if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_GET_SOFTWARE_VERSION) {
                // Skip the ServiceID, Status and Lenght bytes and start from the String containing the ECU Software Version
                text.append(DltUtil.toAscii(Arrays.copyOfRange(payload, 9, payload.length), DltUtil.ToAsciiMode.HEX));
            } else if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_CONNECTION_INFO) {
                if (payload.length == DltServiceConnectionInfo.sizeOf) {
                    DltStream s = new DltStream(payload, 0, payload.length, endianness);
                    DltServiceConnectionInfo service = new DltServiceConnectionInfo(s);
                    switch (service.state) {
                        case DltConstants.DLT_CONNECTION_STATUS_DISCONNECTED:
                            text.append("disconnected");
                            break;
                        case DltConstants.DLT_CONNECTION_STATUS_CONNECTED:
                            text.append("connected");
                            break;
                        default:
                            text.append("unknown");
                    }
                    text.append(' ').append(service.comid);
                } else {
                    byte[] connectionStatePayload = Arrays.copyOfRange(payload, 5, payload.length);
                    text.append(DltUtil.toAscii(connectionStatePayload));
                }
            } else if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_TIMEZONE) {
                if (payload.length == DltServiceTimezone.sizeOf) {
                    DltServiceTimezone service = new DltServiceTimezone(new DltStream(payload, 0, payload.length, endianness));

                    text.append(service.timezone).append(" s");
                    if (service.isdst)
                        text.append(" DST");
                } else {
                    text.append(DltUtil.toAscii(Arrays.copyOfRange(payload, 5, payload.length)));
                }
            } else {
                text.append(DltUtil.toAscii(Arrays.copyOfRange(payload, 5, payload.length)));
            }

            return text.toString();
        }

        if (type == DltTypeDef.Control) {
            text.append('[').append(getCtrlServiceIdString()).append("] ");
            text.append(DltUtil.toAscii(Arrays.copyOfRange(payload, 4, payload.length)));
            return text.toString();
        }
        text.append(
                arguments.stream().map(DltArgument::toString).collect(Collectors.joining(" ")));
        return text.toString();
    }

    static final String[] qDltCtrlServiceId =
            {"", "set_log_level", "set_trace_status", "get_log_info", "get_default_log_level", "store_config", "reset_to_factory_default",
                    "set_com_interface_status", "set_com_interface_max_bandwidth", "set_verbose_mode", "set_message_filtering", "set_timing_packets",
                    "get_local_time", "use_ecu_id", "use_session_id", "use_timestamp", "use_extended_header", "set_default_log_level", "set_default_trace_status",
                    "get_software_version", "message_buffer_overflow"};

    public String getCtrlServiceIdString() {
        if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_UNREGISTER_CONTEXT)
            return "unregister_context";
        else if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_CONNECTION_INFO)
            return "connection_info";
        else if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_TIMEZONE)
            return "timezone";
        else if (ctrlServiceId == DltConstants.DLT_SERVICE_ID_MARKER)
            return "marker";
        else if (ctrlServiceId < qDltCtrlServiceId.length)
            return qDltCtrlServiceId[(int) ctrlServiceId];
        else
            return Long.toString(ctrlServiceId);
    }

    static final String[] qDltCtrlReturnType = {"ok", "not supported", "error", "3", "4", "5", "6", "7", "no matching context id"};

    public String getCtrlReturnTypeString() {
        if (ctrlReturnType >= 0 && ctrlReturnType < qDltCtrlReturnType.length)
            return qDltCtrlReturnType[ctrlReturnType];
        else
            return Long.toString(ctrlReturnType);
    }

}
